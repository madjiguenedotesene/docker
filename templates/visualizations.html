<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üì•Charger Donn√©es - Eurosmart Analytics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclure le script de style si vous en avez un (gard√© du code original) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body class="flex flex-col min-h-screen">

    <nav class="fixed top-0 left-0 w-full z-10 p-4 top-nav">
    <div class="container mx-auto flex justify-between items-center relative h-10">
        <!-- Logo - C√¥t√© Gauche -->
        <a href="/" class="h-10 flex items-center z-10">
             <img src="static/images/logo.png" alt="Logo Eurosmart Analytics" class="h-12">
        </a>
        
        <!-- Nouveau Cercle de Texte Rotatif - C√¥t√© Droit -->
        <div class="rotating-text-container">
            <div class="rotating-content">
                <!-- LE CONTENU EST DUPLIQU√â CI-DESSOUS POUR UN EFFET DE BOUCLE SANS PAUSE -->
               
                <span>CHARGER</span>
                <span class="dot">‚Ä¢</span>
                <span>NETTOYER</span>
                <span class="dot">‚Ä¢</span>
                <span>VISUALISER</span>
                <span class="dot">‚Ä¢</span>
                <span>PR√âDIRE</span>
                <span class="dot">‚Ä¢</span>
                
                
                <span>CHARGER</span>
                <span class="dot">‚Ä¢</span>
                <span>NETTOYER</span>
                <span class="dot">‚Ä¢</span>
                <span>VISUALISER</span>
                <span class="dot">‚Ä¢</span>
                <span>PR√âDIRE</span>
                <span class="dot">‚Ä¢</span>
            </div>
        </div>
        
    </div>
</nav>


    <main class="container mx-auto p-8 flex-grow mb-20"> 
        <h1 class="text-3xl md:text-4xl font-extrabold mb-4 text-white text-center">Visualisation des Donn√©es</h1>
        <p class="text-white mb-8 text-center">Cr√©ez des graphiques interactifs pour explorer votre jeu de donn√©es.</p>
        
        <!-- CARTE 1: S√âLECTION DES PARAM√àTRES -->
        <div id="selection-card" class="main-card p-6 md:p-10 text-center">
            <h2 class="text-2xl font-bold mb-6 text-gray-700">Param√®tres du Graphique</h2>

            <form id="plot-form" class="space-y-4">
                
                <div class="flex flex-col md:flex-row md:space-x-4 md:space-y-0 space-y-4">
                    
                    <div class="flex-1">
                        <label for="plotType" class="block text-left text-gray-700 font-bold mb-2">Type de graphique</label>
                        <select id="plotType" name="plotType" class="w-full p-2 border border-gray-300 rounded-md">
                            <option value="line">Lignes (S√©rie Temporelle)</option>
                            <option value="bar">Barres (S√©rie Temporelle)</option>
                            <option value="scatter">Nuage de points</option>
                            <option value="box">Bo√Æte √† moustaches</option>
                            <option value="distribution_histogram">Histogramme de distribution</option>
                            <option value="pie">Secteurs</option>
                        </select>
                    </div>
                    
                    <div id="time-granularity-container" class="flex-1">
                        <label for="timeGranularity" class="block text-left text-gray-700 font-bold mb-2">Granularit√© Temporelle</label>
                        <select id="timeGranularity" name="timeGranularity" class="w-full p-2 border border-gray-300 rounded-md">
                            <option value="raw">Donn√©es Brutes (Tout)</option>
                            <option value="H">Par Heure (Moyenne)</option>
                            <option value="D">Par Jour (Moyenne)</option>
                            <option value="W">Par Semaine (Moyenne)</option>
                            <option value="M">Par Mois (Moyenne)</option>
                        </select>
                    </div>

                    <div id="x-col-container" class="flex-1">
                        <label for="xCol" class="block text-left text-gray-700 font-bold mb-2">Axe X</label>
                        <select id="xCol" name="xCol" class="w-full p-2 border border-gray-300 rounded-md"></select>
                    </div>
                </div>

                <div class="flex flex-col md:flex-row md:space-x-4 md:space-y-0 space-y-4">
                    
                    <div id="y-col-container" class="flex-1">
                        <label for="yCol" class="block text-left text-gray-700 font-bold mb-2">Axe Y</label>
                        <select id="yCol" name="yCol" class="w-full p-2 border border-gray-300 rounded-md"></select>
                    </div>
                    <div id="color-col-container" class="flex-1">
                        <label for="colorCol" class="block text-left text-gray-700 font-bold mb-2">Couleur (selon X ou Y)</label>
                        <select id="colorCol" name="colorCol" class="w-full p-2 border border-gray-300 rounded-md"></select>
                    </div>

                    <div id="color-type-container" class="flex-1">
                        <label for="colorType" class="block text-left text-gray-700 font-bold mb-2">Type de couleur</label>
                        <select id="colorType" name="colorType" class="w-full p-2 border border-gray-300 rounded-md">
                            </select>
                    </div>
                    
                    <div id="city-filter-container" class="flex-1">
                        <label for="city-filter" class="block text-left text-gray-700 font-bold mb-2">Filtrer par Ville</label>
                        <select id="city-filter" name="city-filter" class="w-full p-2 border border-gray-300 rounded-md"></select>
                    </div>
                </div>

                <button type="submit" class="btn-gradient w-full md:w-auto mt-6">G√©n√©rer le graphique ‚ú®</button>
            </form>
        </div>
        
        <!-- CARTE 2: AFFICHAGE DU GRAPHIQUE -->
        <div id="plot-card" class="main-card p-6 md:p-10 text-center mt-8 hidden">
            <h2 class="text-2xl font-bold mb-6 text-gray-700">R√©sultat de la Visualisation</h2>

            <div id="message-container" class="mt-4 text-center text-lg">S√©lectionnez vos param√®tres et cliquez sur 'G√©n√©rer le graphique'.</div>

            <div class="plot-container-wrapper">
                <div id="plot-container" class="w-full h-96">
                    <!-- Le graphique Plotly sera ins√©r√© ici -->
                </div>
            </div>

            <div id="redirect-btn-container" class="mt-6 flex flex-wrap gap-4 justify-center hidden">
                <button id="downloadPlotBtn" class="btn-gradient">üñºÔ∏è T√©l√©charger le graphique (PNG)</button>
                <button onclick="window.location.href='/prediction-modeling'" class="btn-gradient">Aller √† la page Pr√©diction</button>
            </div>
        </div>
    </main>

    <footer class="footer-transparent text-gray-400 p-4 mt-8 text-center">
        <div class="container mx-auto">
            <div class="flex justify-center items-center space-x-6 text-2xl mb-4">
                <a href="/upload" class="transform hover:scale-110 transition duration-300">üì•</a>
                <a href="/data-preparation" class="transform hover:scale-110 transition duration-300">üßπ</a>
                <a href="/visualizations" class="transform hover:scale-110 transition duration-300">üìä</a>
                <a href="/prediction-modeling" class="transform hover:scale-110 transition duration-300">üîÆ</a>
            </div>
            <p class="text-sm mt-4">&copy; 2026 Eurosmart Analytics. Tous droits r√©serv√©s. ‚ú®</p>
            <p class="text-sm mt-2">
                <span class="mr-2">üìû</span>
                <a href="tel:+33160626566" class="hover:underline">+33 1 60 62 65 66</a>
            </p>
        </div>
    </footer>
    <script>
        const messageContainer = document.getElementById('message-container');
        const plotForm = document.getElementById('plot-form');
        const plotContainer = document.getElementById('plot-container');
        const xColSelect = document.getElementById('xCol');
        const yColSelect = document.getElementById('yCol');
        const colorColSelect = document.getElementById('colorCol');
        const colorTypeSelect = document.getElementById('colorType');
        const plotTypeSelect = document.getElementById('plotType');
        const cityFilterSelect = document.getElementById('city-filter');
        const cityFilterContainer = document.getElementById('city-filter-container');
        const redirectBtnContainer = document.getElementById('redirect-btn-container');
        const downloadPlotBtn = document.getElementById('downloadPlotBtn');
        const timeGranularitySelect = document.getElementById('timeGranularity'); 
        
        let allColumns = []; // Stocke toutes les colonnes r√©cup√©r√©es
        let timeColumns = []; // Stocke les colonnes de temps

        // Mappage des noms de colonnes aux types de cat√©gories pour la coloration
        const columnTypeMapping = {
           
            'temp': { value: 'temperature', text: 'Temp√©rature' }, 
            'hum': { value: 'humidity', text: 'Humidit√©' }, 
            'cov': { value: 'cov', text: 'Compos√©s Organiques Volatils' },
            'iqa': { value: 'iqa', text: 'Qualit√© de l\'Air' },
            'pm': { value: 'pm', text: 'Particules Fines' },
            'co2': { value: 'co2', text: 'CO‚ÇÇ' },
            'nox': { value: 'nox', text: 'NO‚Çì' },
            'lumiere': { value: 'light', text: 'Luminosit√©' }, 
        };

        const displayMessage = (msg, type) => {
            messageContainer.textContent = msg;
            messageContainer.style.color = (type === 'error') ? '#ff4d4d' : 'black';
        };
        
        // Fonction utilitaire pour normaliser la cha√Æne (supprimer accents et espaces)
        const normalizeString = (str) => {
            if (!str) return '';
            // Utilise NFD pour d√©composer les caract√®res accentu√©s, puis supprime les marques diacritiques
            return str.toLowerCase()
                      .normalize("NFD")
                      .replace(/[\u0300-\u036f]/g, "")
                      .replace(/\s/g, ''); // Supprime uniquement les espaces blancs
        };


        const fetchDataFrameInfo = async () => {
            try {
                const response = await fetch('/get_data_info');
                const result = await response.json();
                if (response.ok) {
                    allColumns = result.data_info.columns;
                    
                    // D√©terminer les colonnes de temps (on suppose celles qui contiennent 'date', 'heure', ou 'temps')
                    // FIX: Ajout de 'temps' √† la liste des mots-cl√©s pour d√©tecter les colonnes de temps.
                    timeColumns = allColumns.filter(col => 
                        normalizeString(col).includes('date') || 
                        normalizeString(col).includes('heure') ||
                        normalizeString(col).includes('temps')
                    );
                    
                    // Colonnes non-temps pour les s√©lecteurs Y et X (pour les non-temporels)
                    const nonTimeColumns = allColumns.filter(col => !timeColumns.includes(col));

                    // Remplir le s√©lecteur Y en excluant le temps (Nouveau)
                    populateSelect(yColSelect, nonTimeColumns);
                    
                    // Mettre √† jour Axe X et les options de couleur
                    updateXColOptions();
                    // Initialiser les options de couleur bas√©es sur les s√©lections initiales
                    updateColorColOptions();

                } else {
                    displayMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('Erreur lors de la r√©cup√©ration des colonnes:', error);
                displayMessage('Une erreur est survenue lors du chargement des colonnes.', 'error');
            }
        };

        const fetchUniqueCities = async () => {
            try {
                const response = await fetch('/get_unique_cities');
                const result = await response.json();
                if (response.ok && result.cities) {
                    populateSelect(cityFilterSelect, result.cities, true, 'Toutes les villes');
                } else {
                    // Masquer le filtre si les villes ne sont pas disponibles
                    cityFilterContainer.style.display = 'none';
                }
            } catch (error) {
                console.error('Erreur lors de la r√©cup√©ration des villes:', error);
                cityFilterContainer.style.display = 'none';
            }
        };

        const populateSelect = (selectElement, options, includeEmpty = false, emptyText = 'S√©lectionnez...') => {
            selectElement.innerHTML = '';
            if (includeEmpty) {
                const emptyOption = document.createElement('option');
                emptyOption.value = "";
                emptyOption.textContent = emptyText;
                selectElement.appendChild(emptyOption);
            }
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
        };

        // G√®re la s√©lection des options pour l'Axe X
        const updateXColOptions = () => {
            const plotType = plotTypeSelect.value;
            const xColContainer = document.getElementById('x-col-container');
            
            // Les graphiques de type Ligne et Barre sont des s√©ries temporelles
            const isTimeSeries = ['line', 'bar'].includes(plotType);
            
            // R√©initialiser
            xColSelect.innerHTML = '';
            xColSelect.disabled = false;
            
            if (isTimeSeries) {
                // Pour les s√©ries temporelles, X est le temps
                if (timeColumns.length > 0) {
                    // Utiliser la premi√®re colonne de temps trouv√©e (Date/Heure)
                    const timeColName = timeColumns[0];
                    populateSelect(xColSelect, [timeColName], false, timeColName);
                    xColSelect.disabled = true; // Emp√™cher l'utilisateur de changer l'axe X
                    xColContainer.querySelector('label').textContent = 'Axe X (Temps)';
                } else {
                    // Cas d'erreur si aucune colonne de temps n'est trouv√©e pour la s√©rie temporelle
                    populateSelect(xColSelect, ['Date/Heure non trouv√©e']);
                    xColSelect.disabled = true;
                    xColContainer.querySelector('label').textContent = 'Axe X (Temps)';
                }
                
            } else {
                // Pour les autres graphiques, X peut √™tre n'importe quelle colonne.
                // Exclusion compl√®te du temps pour PIE, BOX, SCATTER
                const nonTimeColumns = allColumns.filter(col => !timeColumns.includes(col));

                if (['pie', 'box', 'scatter'].includes(plotType)) {
                     // Exclure TOUTES les colonnes de temps de la s√©lection X
                    populateSelect(xColSelect, nonTimeColumns);
                } else {
                    // Pour Histograms et autres, utiliser toutes les colonnes non-temps (d√©j√† le cas, mais explicit√©)
                    populateSelect(xColSelect, allColumns); 
                }
                
                // Mettre √† jour le label
                xColContainer.querySelector('label').textContent = 'Axe X';
            }
            
            // Mettre √† jour les options de couleur
            updateColorColOptions();
        };
        
        //  Mettre √† jour les options de la colonne 'Couleur'
        const updateColorColOptions = () => {
            const plotType = plotTypeSelect.value;
            const xCol = xColSelect.value;
            const yCol = yColSelect.value;
            
            const options = [];
            options.push({ value: "", text: "Aucun" });

            const isTimeSeriesPlot = ['line'].includes(plotType); 
            
            // 1. Ajouter l'Axe X comme option de couleur
           
            if (xCol && xCol !== 'Date/Heure non trouv√©e' && !isTimeSeriesPlot) {
                 // S'assurer que X n'est pas une colonne de temps pour les non-temporels
                if (!timeColumns.includes(xCol)) {
                    options.push({ value: xCol, text: xCol });
                }
            }

            // 2. Ajouter l'Axe Y comme option de couleur
            // Y est une variable s√©lectionn√©e et est visible dans la configuration.
            if (['scatter', 'bar', 'pie'].includes(plotType) && yCol) {
                // Ajouter Y uniquement si elle est diff√©rente de X (pour √©viter les doublons) et n'est pas une colonne de temps.
                if (yCol !== xCol && !timeColumns.includes(yCol)) {
                    options.push({ value: yCol, text: yCol });
                }
            }
            
            // Pour les secteurs (pie) et bo√Ætes (box) et histogramme, X est la variable principale
            if (['pie', 'box', 'distribution_histogram'].includes(plotType) && xCol && xCol !== 'Date/Heure non trouv√©e') {
                const isXInOptions = options.some(opt => opt.value === xCol);
                if (!isXInOptions && !timeColumns.includes(xCol)) {
                    options.push({ value: xCol, text: xCol });
                }
            }

            // Filtre les doublons et peuple le select
            colorColSelect.innerHTML = '';
            const uniqueOptions = new Map();
            options.forEach(opt => uniqueOptions.set(opt.value, opt.text));

            uniqueOptions.forEach((text, value) => {
                const opt = document.createElement('option');
                opt.value = value;
                opt.textContent = text;
                colorColSelect.appendChild(opt);
            });

            // S'assurer que le type de couleur est mis √† jour imm√©diatement
            updateColorTypeOptions();
        };


        const togglePlotOptions = () => {
            const plotType = plotTypeSelect.value;
            
            // Mettre √† jour l'Axe X en fonction du type de graphique
            updateXColOptions();
            
            // Granularit√© temporelle est visible uniquement pour les s√©ries temporelles (Line, Bar)
            const isTimeSeries = ['line', 'bar'].includes(plotType);
            document.getElementById('time-granularity-container').style.display = isTimeSeries ? 'block' : 'none';
            
            // Axe Y est cach√© pour les graphiques de secteurs, bo√Ætes et histogrammes
            document.getElementById('y-col-container').style.display = ['pie', 'box', 'distribution_histogram'].includes(plotType) ? 'none' : 'block';

            // Masque la colonne de couleur pour les Box Plot, Histogrammes ET Lignes (Line seulement maintenant)
        
            const hideColor = ['distribution_histogram', 'box', 'line'].includes(plotType);
            document.getElementById('color-col-container').style.display = hideColor ? 'none' : 'block';
            document.getElementById('color-type-container').style.display = hideColor ? 'none' : 'block';
            
            // Le filtre par ville est conserv√© visible
            document.getElementById('city-filter-container').style.display = 'block'; 
            
            // Mettre √† jour les options de couleur bas√©es sur les changements de X/Y/Type de graphique
            updateColorColOptions();
        };

        const updateColorTypeOptions = () => {
            const selectedCol = colorColSelect.value;
            colorTypeSelect.innerHTML = '';
            
            const emptyOption = document.createElement('option');
            emptyOption.value = "none";
            emptyOption.textContent = "Aucun";
            colorTypeSelect.appendChild(emptyOption);

            if (selectedCol) {
                // Normalise la cha√Æne pour la d√©tection du type de couleur
                const normalizedCol = normalizeString(selectedCol);
                
                // Cherche la cl√© correspondante dans la colonne normalis√©e
                const colKey = Object.keys(columnTypeMapping).find(key => normalizedCol.includes(key));
                
                if (colKey) {
                    const mappedType = columnTypeMapping[colKey];
                    const opt = document.createElement('option');
                    opt.value = mappedType.value;
                    opt.textContent = mappedType.text;
                    colorTypeSelect.appendChild(opt);
                    
                    //Force la s√©lection du type de couleur correspondant
                    colorTypeSelect.value = mappedType.value;
                }
            } else {
                 // Si "Aucun" est s√©lectionn√©, s'assurer que le type de couleur est aussi "Aucun"
                 colorTypeSelect.value = "none";
            }
        };

       
        plotForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            // Rendre la carte d'affichage visible au d√©but de la soumission
            document.getElementById('plot-card').classList.remove('hidden');

            const plotType = plotTypeSelect.value;
            const xCol = xColSelect.value;
            
            // Les types de graphiques pour lesquels les options de couleur sont masqu√©es et doivent √™tre forc√©es √† vide
            const plotsWithoutColorGrouping = ['distribution_histogram', 'box', 'line'];

            // Assurer que YCol est vide pour les Box Plots, Histograms et Secteurs 
            const yCol = ['pie', 'box', 'distribution_histogram'].includes(plotType) ? "" : yColSelect.value;
            
            // Assurer que ColorCol et ColorType sont vides pour les graphiques sans option de couleur visible (Line, Box, Histogram)
            const colorCol = plotsWithoutColorGrouping.includes(plotType) ? "" : colorColSelect.value;
            const colorType = plotsWithoutColorGrouping.includes(plotType) ? "none" : colorTypeSelect.value;

            const city = cityFilterSelect.value;
            const timeGranularity = timeGranularitySelect.value; 
            
            // axe X
            if (!xCol || xCol === 'Date/Heure non trouv√©e') {
                displayMessage('Veuillez s√©lectionner des donn√©es valides pour l\'axe X.', 'error');
                return;
            }
            // Validation pour l'Axe Y pour les graphiques qui en ont besoin
            if (['scatter', 'bar', 'line'].includes(plotType) && !yCol) {
                displayMessage('Veuillez s√©lectionner une colonne pour l\'axe Y.', 'error');
                return;
            }
            
            if (['pie'].includes(plotType) && !colorCol) {
                displayMessage('Veuillez s√©lectionner une colonne pour le graphique de secteur.', 'error');
                return;
            }

            displayMessage('G√©n√©ration du graphique...', 'info');
           
           // plotContainer.innerHTML = '<p class="text-gray-600 text-center">Chargement du graphique...</p>';

            try {
                const response = await fetch('/generate_plot', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        plotType,
                        xCol,
                        yCol, 
                        colorCol, 
                        colorType, 
                        city,
                        timeGranularity 
                    }),
                });

                const result = await response.json();
                
                if (response.ok) {
                    const plotData = JSON.parse(result.plot_json);
                    
                    Plotly.newPlot('plot-container', plotData.data, plotData.layout, { responsive: true });
                    displayMessage('Graphique g√©n√©r√© avec succ√®s ! üéâ', 'success');
                    redirectBtnContainer.classList.remove('hidden');

                } else {
                    displayMessage(result.error, 'error');
                    plotContainer.innerHTML = '<p class="text-gray-600 text-center">√âchec de la g√©n√©ration du graphique. üíî</p>';
                }
            } catch (error) {
                console.error('Erreur lors de la g√©n√©ration du graphique:', error);
                displayMessage('Une erreur inattendue est survenue lors de la g√©n√©ration du graphique.', 'error');
            }
        });

        downloadPlotBtn.addEventListener('click', () => {
            Plotly.downloadImage('plot-container', { format: 'png', filename: 'mon_graphique' });
        });

        document.addEventListener('DOMContentLoaded', () => {
            fetchDataFrameInfo();
            fetchUniqueCities();
            togglePlotOptions();
            
        });

        // √âv√©nements pour d√©clencher les mises √† jour de couleur
        plotTypeSelect.addEventListener('change', togglePlotOptions);
        xColSelect.addEventListener('change', updateColorColOptions);
        yColSelect.addEventListener('change', updateColorColOptions);
        colorColSelect.addEventListener('change', updateColorTypeOptions);
    </script>
</body>
</html>
