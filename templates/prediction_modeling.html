<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîÆPrediction - Eurosmart Analytics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
        /* Ajustement CSS pour le conteneur de la matrice de corr√©lation */
        #correlation-plot {
            width: 100%; /* Prend toute la largeur disponible */
            height: 500px; /* Hauteur fixe pour la matrice */
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <nav class="fixed top-0 left-0 w-full z-10 p-4 top-nav">
        <div class="container mx-auto flex justify-between items-center relative h-10">
            <a href="/" class="h-10 flex items-center z-10">
                 <img src="static/images/logo.png" alt="Logo Eurosmart Analytics" class="h-12">
            </a>
            
            <a href="/" class="h-10 flex items-center justify-end z-10">
                 <img src="static/images/pollugard.png" alt="Logo Pollugard" class="h-12">
            </a>
        </div>
    </nav>


    <main class="container mx-auto p-8 flex-grow">
        
        <h1 class="text-3xl md:text-4xl font-extrabold mb-4 text-white text-center">Pr√©diction et Mod√©lisation</h1>
        <p class="text-gray-600 mb-8 text-center"></p>

        <!-- Section Corr√©lation -->
        <div class="main-card p-6 md:p-10 text-center mb-8">
            <div class="mb-8">
                <button id="getCorrelationBtn" class="btn-gradient flex items-center justify-center mx-auto">
                    <span id="correlation-text">Analyser les corr√©lations</span>
                    <span id="correlation-spinner" class="loading-spinner ml-2 hidden"></span>
                </button>
            </div>
        </div>

        <div id="correlation-section" class="main-card text-center mb-8 hidden">
            <div class="p-6 md:p-10 text-center">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Matrice de Corr√©lation</h2>
            </div>
            
            <div id="correlation-plot" class="plot-container"></div>
            
            <div class="p-6 md:p-10 text-center">
                <button id="downloadCorrelationBtn" class="btn-gradient mt-4">T√©l√©charger la matrice</button>
            </div>
        </div>

        <!-- Section Formulaire de Pr√©diction -->
        <div class="main-card p-6 md:p-10 text-center mb-8">
            <form id="prediction-form" class="space-y-4 pt-8">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Configuration du Mod√®le</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-left">
                    <!-- Variable Cible -->
                    <div>
                        <label for="targetCol" class="block text-gray-700 font-bold mb-2">Variable Cible</label>
                        <select id="targetCol" name="targetCol" class="w-full p-2 border border-gray-300 rounded-md text-gray-900 focus:ring-2 focus:ring-blue-500"></select>
                    </div>

                    <!-- Choix du Mod√®le (Correction ici) -->
                    <div>
                        <label for="modelSelect" class="block text-gray-700 font-bold mb-2">Mod√®les</label>
                        <select id="modelSelect" name="modelSelect" class="w-full p-2 border border-gray-300 rounded-md text-gray-900 focus:ring-2 focus:ring-blue-500">
                            <option value="all">Comparaison (Tous)</option>
                            <option value="lr" selected>R√©gression Lin√©aire</option>
                            <option value="rf">Random Forest</option>
                            <option value="gb">Gradient Boosting</option>
                        </select>
                    </div>

                    <!-- Variables Explicatives (Mise √† jour label et suppression auto-filtrage) -->
                    <div>
                        <label for="explanatoryCols" class="block text-gray-700 font-bold mb-2">Variables Explicatives</label>
                        <select id="explanatoryCols" name="explanatoryCols" multiple class="w-full p-2 border border-gray-300 rounded-md h-32 text-gray-900 focus:ring-2 focus:ring-blue-500"></select>
                        <p class="text-xs text-gray-500 mt-1">Maintenez Ctrl (ou Cmd) pour s√©lectionner plusieurs variables.</p>
                    </div>
                </div>

                <button type="submit" id="train-btn" class="btn-gradient w-full md:w-auto flex items-center justify-center mx-auto mt-6">
                    <span id="train-text">Entra√Æner et Pr√©dire</span>
                    <span id="train-spinner" class="loading-spinner ml-2 hidden"></span>
                </button>
            </form>
            <div id="message-container" class="mt-4 text-center text-lg"></div>
        </div>

        <!-- Section R√©sultats -->
        <div id="results-section" class="main-card p-6 md:p-10 text-center hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">R√©sultats de la Pr√©diction</h2>
            
           

            <!-- M√©triques de performance -->
            <div id="prediction-metrics" class="bg-gray-100 p-6 rounded-2xl mb-8 text-left text-gray-800 grid grid-cols-1 md:grid-cols-3 gap-4">
                <!-- Rempli dynamiquement par JS -->
            </div>
            
            <h3 class="text-2xl font-bold mb-4 text-gray-800">Graphique Pr√©visionnel</h3>
            <div id="prediction-plot" class="plot-container"></div> 
            
            <div id="table-container-wrapper">
                 <button id="toggleTableBtn" class="btn-gradient mt-4 mb-4">Afficher le Tableau des Pr√©dictions</button>
                 <div id="predictionTableContainer" class="data-table mt-4 hidden">
                    <!-- Table remplie dynamiquement par JS -->
                 </div>
            </div>

            <div id="redirect-btn-container" class="mt-6 flex flex-wrap gap-4 justify-center hidden">
                <button id="downloadPredictionBtn" class="btn-gradient">T√©l√©charger le graphique</button>
                <button onclick="window.location.href='/comparaison'" class="btn-gradient">Aller √† la page de comparaison</button>
            </div>
        </div>

    </main>

    <footer class="footer-transparent text-gray-400 p-4 mt-8 text-center">
        <div class="container mx-auto">
            <div class="flex justify-center items-center space-x-6 text-2xl mb-4">
                <a href="/" class="transform hover:scale-110 transition duration-300">‚ú® Accueil</a>
                <a href="/upload-data" class="transform hover:scale-110 transition duration-300">üìÅ Chargement</a>
                <a href="/data-preparation" class="transform hover:scale-110 transition duration-300">üßº Nettoyage</a>
                <a href="/visualizations" class="transform hover:scale-110 transition duration-300">üìà Visualisation</a>
                <a href="/prediction-modeling" class="transform hover:scale-110 transition duration-300">üîÆ Pr√©diction</a>
                <a href="/comparaison" class="transform hover:scale-110 transition duration-300">üåê Comparaison</a>
            </div>
        </div>
    </footer>

    <script>
        // √âl√©ments DOM
        const getCorrelationBtn = document.getElementById('getCorrelationBtn');
        const correlationSection = document.getElementById('correlation-section');
        const correlationPlot = document.getElementById('correlation-plot');
        const downloadCorrelationBtn = document.getElementById('downloadCorrelationBtn');
        
        const targetColSelect = document.getElementById('targetCol');
        const explanatoryColsSelect = document.getElementById('explanatoryCols');
        const modelSelect = document.getElementById('modelSelect');
        
        const predictionForm = document.getElementById('prediction-form');
        const predictionMetricsDiv = document.getElementById('prediction-metrics');
        const predictionPlotDiv = document.getElementById('prediction-plot');
        const resultsSection = document.getElementById('results-section');
    
        const predictionTableContainer = document.getElementById('predictionTableContainer');
        
        const messageContainer = document.getElementById('message-container');
        const trainBtn = document.getElementById('train-btn');
        const trainText = document.getElementById('train-text');
        const trainSpinner = document.getElementById('train-spinner');
        const redirectBtnContainer = document.getElementById('redirect-btn-container');
        const downloadPredictionBtn = document.getElementById('downloadPredictionBtn');
        const correlationText = document.getElementById('correlation-text');
        const correlationSpinner = document.getElementById('correlation-spinner');
        const toggleTableBtn = document.getElementById('toggleTableBtn');

        let allColumns = [];
        // Mots cl√©s pour l'auto-s√©lection
        const targetKeywords = ['temp√©rature', 'humidit√©','pm', 'cov', 'co2','iqa', 'lumi√®re'];
        const meteoKeywords = ['temp√©rature', 'humidit√©', 'lumi√®re','pression'];
        const pollutantKeywords = ['pm', 'cov','iqa', 'co2'];
        const permanentExclusionsKeywords = [
             'la diff', 'le mois', 'la ville', 
            'temps', 'date','nox' ,'le point rose',  'heure','point_de_rosee', 'diff_temp_rosee'
        ];

        // --- Fonction d'agr√©gation horaire ---
        const aggregateToHourlyMean = (predictions) => {
            if (!predictions || predictions.length === 0) return [];
            
            const hourlyGroups = {};

            predictions.forEach((p) => {
                const date = new Date(p.time.replace(' ', 'T'));
                // Cl√© unique par heure (YYYY-MM-DD-HH)
                const hourKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}-${date.getHours()}`;

                if (!hourlyGroups[hourKey]) {
                    hourlyGroups[hourKey] = {
                        sum: 0,
                        count: 0,
                        firstTime: p.time, 
                        firstDateObj: date
                    };
                }
                
                // On garde le timestamp le plus t√¥t pour l'affichage
                if (date < hourlyGroups[hourKey].firstDateObj) {
                     hourlyGroups[hourKey].firstDateObj = date;
                     hourlyGroups[hourKey].firstTime = p.time;
                }

                hourlyGroups[hourKey].sum += p.value;
                hourlyGroups[hourKey].count += 1;
            });

            const aggregatedList = Object.values(hourlyGroups).map(group => {
                const date = new Date(group.firstTime.replace(' ', 'T'));
                
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const timePart = date.toTimeString().substring(0, 5); 
                
                const displayDateTime = `${day}/${month} ${timePart}`;
                
                return {
                    time: displayDateTime, 
                    value: group.sum / group.count 
                };
            });

            // Tri chronologique
            aggregatedList.sort((a, b) => {
                return 0; 
            });
            
            return aggregatedList;
        };

        const displayMessage = (msg, type) => {
            if (type === 'success' || type === 'info') {
                messageContainer.textContent = '';
            } else {
                messageContainer.textContent = msg;
                messageContainer.style.color = (type === 'error') ? '#ff4d4d' : 'black';
            }
        };

        // --- Chargement des Colonnes ---
        const fetchAndPopulateColumns = async () => {
            try {
                const response = await fetch('/get_data_columns');
                const result = await response.json();
                if (response.ok) {
                    allColumns = result.columns;
                    
                    const filteredTargets = allColumns.filter(col => 
                        targetKeywords.some(keyword => col.toLowerCase().includes(keyword))
                    );

                    populateSelect(targetColSelect, filteredTargets);

                    const defaultTarget = filteredTargets.find(col => col.toLowerCase().includes('temp√©rature'));
                    if (defaultTarget) {
                        targetColSelect.value = defaultTarget;
                    } else if (filteredTargets.length > 0) {
                        targetColSelect.value = filteredTargets[0];
                    }

                    updateExplanatoryVariables();
                } else {
                    displayMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('Erreur colonnes:', error);
                displayMessage('Erreur chargement colonnes.', 'error');
            }
        };

        const populateSelect = (selectElement, options) => {
            selectElement.innerHTML = '';
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
        };

        const updateExplanatoryVariables = () => {
            const targetCol = targetColSelect.value;
            const lowerTargetCol = targetCol.toLowerCase();
            let isMeteoTarget = meteoKeywords.some(keyword => lowerTargetCol.includes(keyword));
            let isPollutantTarget = pollutantKeywords.some(keyword => lowerTargetCol.includes(keyword));

            const explanatoryColumns = allColumns.filter(col => {
                const lowerCol = col.toLowerCase();
                if (col === targetCol) return false;
                
                const isPermanentlyExcluded = permanentExclusionsKeywords.some(keyword => lowerCol.includes(keyword));
                if (isPermanentlyExcluded) return false;
                
                if (isMeteoTarget) {
                    return meteoKeywords.some(keyword => lowerCol.includes(keyword));
                } else if (isPollutantTarget) {
                    return true;
                }
                return true;
            });
            
            populateSelect(explanatoryColsSelect, explanatoryColumns);
            
            // S√©lectionner tout par d√©faut
            Array.from(explanatoryColsSelect.options).forEach(option => {
                option.selected = true;
            });
        };

        // --- Corr√©lation ---
        const fetchCorrelationMatrix = async () => {
            correlationText.classList.add('hidden');
            correlationSpinner.classList.remove('hidden');
            getCorrelationBtn.disabled = true;
            displayMessage('', 'info');
            
            correlationPlot.innerHTML = '';
            correlationSection.classList.remove('hidden'); 

            try {
                const response = await fetch('/get_correlation_matrix');
                const result = await response.json();
                if (response.ok) {
                    const plotData = JSON.parse(result.plot_json);
                    const layout = {
                        ...plotData.layout,
                        autosize: true,
                        width: null,    
                        height: null,   
                        margin: { l: 2, r: 2, t: 3, b: 2 },
                    };
                    Plotly.newPlot('correlation-plot', plotData.data, layout, { responsive: true });
                    displayMessage('', 'success');
                } else {
                    displayMessage(result.error, 'error');
                    correlationSection.classList.add('hidden');
                }
            } catch (error) {
                console.error('Erreur corr√©lation:', error);
                displayMessage('Erreur inattendue.', 'error');
                correlationSection.classList.add('hidden');
            } finally {
                correlationText.classList.remove('hidden');
                correlationSpinner.classList.add('hidden');
                getCorrelationBtn.disabled = false;
            }
        };

        // --- Entra√Ænement et Pr√©diction ---
        const trainAndPredict = async () => {
            const targetCol = targetColSelect.value;
            const selectedModelType = modelSelect.value; // 'all', 'lr', 'rf', 'gb'
            
            const featureCols = Array.from(explanatoryColsSelect.options)
                                         .filter(option => option.selected)
                                         .map(option => option.value);

            if (!targetCol || featureCols.length === 0) {
                displayMessage('S√©lectionnez au moins une variable cible et une explicative.', 'error');
                return;
            }

            trainBtn.disabled = true;
            trainText.classList.add('hidden');
            trainSpinner.classList.remove('hidden');
            displayMessage('', 'info');
            resultsSection.classList.add('hidden');

            try {
                const response = await fetch('/train_predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ targetCol: targetCol, featureCols: featureCols }), 
                });
                const result = await response.json();

                if (response.ok) {
                    // (Suppression du feedback visuel sur la s√©lection auto des variables)

                    // 2. Pr√©parer les donn√©es horaires pour chaque mod√®le
                    const preds_lr = aggregateToHourlyMean(result.predictions_lr || []);
                    const preds_rf = aggregateToHourlyMean(result.predictions_rf || []);
                    const preds_gb = aggregateToHourlyMean(result.predictions_gb || []);

                    // 3. Configuration de l'affichage selon le choix utilisateur
                    let plotTraces = [];
                    let tableHeaders = `<th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Date/Heure</th>`;
                    let metricsHtml = '';

                    // Fonctions utilitaires pour construire l'UI
                    const addMetric = (title, data) => {
                        if(!data) return;
                        metricsHtml += `
                            <div class="bg-white p-4 rounded shadow">
                                <h4 class="font-bold text-blue-600 mb-2">${title}</h4>
                                <p class="text-sm"><strong>R¬≤:</strong> ${(data.r2 !== undefined ? data.r2.toFixed(4) : 'N/A')}</p>
                                <p class="text-sm"><strong>MSE:</strong> ${(data.mse !== undefined ? data.mse.toFixed(4) : 'N/A')}</p>
                                <p class="text-sm"><strong>MAE:</strong> ${(data.mae !== undefined ? data.mae.toFixed(4) : 'N/A')}</p>
                            </div>`;
                    };

                    const addTrace = (name, color, data) => {
                        plotTraces.push({
                            x: data.map(p => p.time),
                            y: data.map(p => p.value),
                            mode: 'lines+markers',
                            name: name,
                            line: { color: color, width: 2 }
                        });
                    };

                    // --- Logique conditionnelle d'affichage ---
                    const showLR = (selectedModelType === 'all' || selectedModelType === 'lr');
                    const showRF = (selectedModelType === 'all' || selectedModelType === 'rf');
                    const showGB = (selectedModelType === 'all' || selectedModelType === 'gb');

                    // Construction Graphique & M√©triques
                    if (showLR) {
                        addMetric("R√©gression Lin√©aire", result.results['Linear Regression']);
                        addTrace("R√©gression Lin√©aire", 'rgb(46, 204, 113)', preds_lr); // Vert
                        tableHeaders += `<th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Lin√©aire (Moy.)</th>`;
                    }
                    if (showRF) {
                        addMetric("Random Forest", result.results['Random Forest']);
                        addTrace("Random Forest", 'rgb(75, 82, 255)', preds_rf); // Bleu
                        tableHeaders += `<th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Rand. Forest (Moy.)</th>`;
                    }
                    if (showGB) {
                        addMetric("Gradient Boosting", result.results['Gradient Boosting']);
                        addTrace("Gradient Boosting", 'rgb(255, 105, 180)', preds_gb); // Rose
                        tableHeaders += `<th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Grad. Boosting (Moy.)</th>`;
                    }

                    // Mise √† jour DOM M√©triques
                    predictionMetricsDiv.innerHTML = metricsHtml;

                    // Construction Tableau
                    // On utilise la liste la plus longue comme r√©f√©rence de temps (elles devraient √™tre identiques)
                    const timeRef = (preds_gb.length > 0 ? preds_gb : (preds_rf.length > 0 ? preds_rf : preds_lr));
                    
                    let tableBodyRows = timeRef.map((refItem, index) => {
                        let rowHtml = `<td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${refItem.time}</td>`;
                        
                        if (showLR) {
                            const val = preds_lr[index] ? preds_lr[index].value : 'N/A';
                            rowHtml += `<td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${typeof val === 'number' ? val.toFixed(2) : val}</td>`;
                        }
                        if (showRF) {
                            const val = preds_rf[index] ? preds_rf[index].value : 'N/A';
                            rowHtml += `<td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${typeof val === 'number' ? val.toFixed(2) : val}</td>`;
                        }
                        if (showGB) {
                            const val = preds_gb[index] ? preds_gb[index].value : 'N/A';
                            rowHtml += `<td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${typeof val === 'number' ? val.toFixed(2) : val}</td>`;
                        }
                        return `<tr class="hover:bg-gray-50">${rowHtml}</tr>`;
                    }).join('');

                    const tableHtml = `
                        <h3 class="text-xl font-bold mb-3 text-gray-800">D√©tail des Pr√©dictions (Moyenne Horaire)</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-200 bg-white rounded-xl shadow-lg">
                                <thead class="bg-gray-50"><tr>${tableHeaders}</tr></thead>
                                <tbody class="divide-y divide-gray-200">${tableBodyRows}</tbody>
                            </table>
                        </div>
                    `;
                    
                    predictionTableContainer.innerHTML = tableHtml;

                    // Affichage Graphique
                    const layout = {
                        title: `Pr√©dictions futures pour ${targetCol}`,
                        xaxis: { title: 'Temps', type: 'category' },
                        yaxis: { title: targetCol },
                        margin: { l: 60, r: 60, b: 60, t: 60 },
                        legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 }
                    };

                    Plotly.newPlot('prediction-plot', plotTraces, layout, { responsive: true });
                    
                    // Finalisation UI
                    displayMessage('', 'success');
                    resultsSection.classList.remove('hidden');
                    redirectBtnContainer.classList.remove('hidden');
                    downloadPredictionBtn.classList.remove('hidden');

                } else {
                    displayMessage(result.error || 'Erreur lors de l\'entra√Ænement.', 'error');
                }
            } catch (error) {
                console.error('Erreur JS:', error);
                displayMessage('Erreur inattendue (Dataset trop petit ou connexion perdue).', 'error');
            } finally {
                trainBtn.disabled = false;
                trainText.classList.remove('hidden');
                trainSpinner.classList.add('hidden');
                // Resize graphique
                setTimeout(() => {
                     if (document.getElementById('prediction-plot').data) Plotly.relayout('prediction-plot', {autosize: true});
                }, 100);
            }
        };

        // --- Event Listeners ---
        toggleTableBtn.addEventListener('click', function() {
            if (predictionTableContainer.classList.contains('hidden')) {
                predictionTableContainer.classList.remove('hidden');
                this.textContent = 'Masquer le Tableau';
            } else {
                predictionTableContainer.classList.add('hidden');
                this.textContent = 'Afficher le Tableau';
            }
        });

        downloadCorrelationBtn.addEventListener('click', () => {
            Plotly.downloadImage('correlation-plot', { format: 'png', filename: 'matrice_correlation' });
        });

        downloadPredictionBtn.addEventListener('click', () => {
            Plotly.downloadImage('prediction-plot', { format: 'png', filename: 'prediction_graph' });
        });

        document.addEventListener('DOMContentLoaded', () => {
            fetchAndPopulateColumns();
            getCorrelationBtn.addEventListener('click', fetchCorrelationMatrix);
            predictionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                trainAndPredict();
            });
            targetColSelect.addEventListener('change', updateExplanatoryVariables);
        });
        
        window.addEventListener('resize', () => {
            const predPlot = document.getElementById('prediction-plot');
            if (predPlot && predPlot.data) Plotly.relayout('prediction-plot', {autosize: true});
            
            const corrPlot = document.getElementById('correlation-plot');
            if (corrPlot && corrPlot.data) Plotly.relayout('correlation-plot', {autosize: true});
        });
    </script>
</body>
</html>