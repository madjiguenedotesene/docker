<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîÆPrediction - Eurosmart Analytics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  
</head>
<body class="flex flex-col min-h-screen">

    <nav class="fixed top-0 left-0 w-full z-10 p-4 top-nav">
    <div class="container mx-auto flex justify-between items-center relative h-10">
        <a href="/" class="h-10 flex items-center z-10">
             <img src="static/images/logo.png" alt="Logo Eurosmart Analytics" class="h-12">
        </a>
        
        <a href="/" class="h-10 flex items-center justify-end z-10">
             <img src="static/images/pollugard.png" alt="Logo Pollugard" class="h-12">
        </a>
        
    </div>
</nav>


    <main class="container mx-auto p-8 flex-grow">
        
        <div class="main-card p-6 md:p-10 text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-extrabold mb-4 text-gray-800">Pr√©diction et Mod√©lisation</h1>
            <p class="text-gray-600 mb-8">Entra√Ænez un mod√®le de r√©gression pour pr√©dire une variable en fonction des autres.</p>
            
            <div class="mb-8">
                <button id="getCorrelationBtn" class="btn-gradient flex items-center justify-center mx-auto">
                    <span id="correlation-text">Analyser les corr√©lations</span>
                    <span id="correlation-spinner" class="loading-spinner ml-2 hidden"></span>
                </button>
            </div>

            <form id="prediction-form" class="space-y-4 pt-8">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Pr√©diction</h2>
                <p class="text-gray-600">S√©lectionnez la variable cible que vous souhaitez pr√©dire et les variables explicatives √† utiliser.</p>
                <div class="flex flex-col md:flex-row md:space-x-4 md:space-y-0 space-y-4">
                    <div class="flex-1">
                        <label for="targetCol" class="block text-left text-gray-700 font-bold mb-2">Variable Cible</label>
                        <select id="targetCol" name="targetCol" class="w-full p-2 border border-gray-300 rounded-md text-gray-900"></select>
                    </div>
                    <div class="flex-1">
                        <label for="explanatoryCols" class="block text-left text-gray-700 font-bold mb-2">Variables Explicatives (Multiple)</label>
                        <select id="explanatoryCols" name="explanatoryCols" multiple class="w-full p-2 border border-gray-300 rounded-md h-32 text-gray-900"></select>
                    </div>
                </div>
                <button type="submit" id="train-btn" class="btn-gradient w-full md:w-auto flex items-center justify-center">
                    <span id="train-text">Entra√Æner et Pr√©dire</span>
                    <span id="train-spinner" class="loading-spinner ml-2 hidden"></span>
                </button>
            </form>

            <div id="message-container" class="mt-4 text-center text-lg"></div>
        </div>

        <div id="correlation-section" class="main-card p-6 md:p-10 text-center mb-8 hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Matrice de Corr√©lation</h2>
            <p class="text-gray-600 mb-4">La matrice de corr√©lation montre les relations entre les variables. Plus la valeur est proche de 1 ou -1, plus la corr√©lation est forte.</p>
            <div id="correlation-plot" class="plot-container mx-auto"></div>
            <button id="downloadCorrelationBtn" class="btn-gradient mt-4">üñºÔ∏è T√©l√©charger la matrice</button>
        </div>

        <div id="results-section" class="main-card p-6 md:p-10 text-center hidden">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">R√©sultats de la Pr√©diction</h2>
            
            <div id="prediction-metrics" class="bg-gray-100 p-6 rounded-2xl mb-8 text-left text-gray-800">
                </div>
            
            <h3 class="text-2xl font-bold mb-4 text-gray-800">Graphique de Pr√©diction</h3>
            <div id="prediction-plot" class="plot-container"></div> 
            
            <div id="redirect-btn-container" class="mt-6 flex flex-wrap gap-4 justify-center hidden">
                <button id="downloadPredictionBtn" class="btn-gradient">üñºÔ∏è T√©l√©charger le graphique</button>
                <button onclick="window.location.href='/comparaison'" class="btn-gradient">Aller √† la page de comparaison</button>
            </div>
        </div>

    </main>

     <footer class="footer-transparent text-gray-400 p-4 mt-8 text-center">
        <div class="container mx-auto">
            <p class="text-sm mt-4">&copy; Cliques sur une ic√¥ne pour acceder √† la page correspondante‚ú®</p>
            <div class="flex justify-center items-center space-x-6 text-2xl mb-4">
                <a href="/" class="transform hover:scale-110 transition duration-300">‚ú® Accueil</a>
                <a href="/upload-data" class="transform hover:scale-110 transition duration-300">üìÅ Chargement</a>
                <a href="/data-preparation" class="transform hover:scale-110 transition duration-300">üßº Nettoyage</a>
                <a href="/visualizations" class="transform hover:scale-110 transition duration-300">üìà Visualisation</a>
                <a href="/prediction-modeling" class="transform hover:scale-110 transition duration-300">üîÆ Pr√©diction</a>
                <a href="/comparaison" class="transform hover:scale-110 transition duration-300">üåê Comparaison</a>
            </div>
            <p class="text-sm mt-4">&copy; 2026 Eurosmart Analytics. Tous droits r√©serv√©s. ‚ú®</p>
            <p class="text-sm mt-2">
                <span class="mr-2">üìû</span>
                <a href="tel:+33160626566" class="hover:underline">+33 1 60 62 65 66</a>
            </p>
        </div>
    </footer>
      <script>
        const getCorrelationBtn = document.getElementById('getCorrelationBtn');
        const correlationSection = document.getElementById('correlation-section');
        const correlationPlot = document.getElementById('correlation-plot');
        const downloadCorrelationBtn = document.getElementById('downloadCorrelationBtn');
        const targetColSelect = document.getElementById('targetCol');
        const explanatoryColsSelect = document.getElementById('explanatoryCols');
        const predictionForm = document.getElementById('prediction-form');
        const predictionMetricsDiv = document.getElementById('prediction-metrics');
        const predictionPlotDiv = document.getElementById('prediction-plot');
        const resultsSection = document.getElementById('results-section');
        const messageContainer = document.getElementById('message-container');
        const trainBtn = document.getElementById('train-btn');
        const trainText = document.getElementById('train-text');
        const trainSpinner = document.getElementById('train-spinner');
        const redirectBtnContainer = document.getElementById('redirect-btn-container');
        const downloadPredictionBtn = document.getElementById('downloadPredictionBtn');
        const correlationText = document.getElementById('correlation-text');
        const correlationSpinner = document.getElementById('correlation-spinner');

        let allColumns = [];
        // Mots-cl√©s des colonnes cibles autoris√©es (insensible √† la casse)
        const targetKeywords = ['temp√©rature', 'humidit√©','pm', 'cov', 'co2', 'lumi√®re'];
        
        // Mots-cl√©s pour le filtrage des explicatives
        const meteoKeywords = ['temp√©rature', 'humidit√©', 'lumi√®re'];
        const pollutantKeywords = ['pm', 'cov', 'co2'];
        
        // Mots-cl√©s des colonnes √† exclure de mani√®re permanente (insensible √† la casse)
        const permanentExclusionsKeywords = [
             'la diff', 'le mois', 'la ville', 
            'temps', 'iqa', 'date','nox' ,'le point rose',  'heure','point_de_rosee', 'diff_temp_rosee','pression'
        ];

        // --------------------------------------------------------------------------------
        // NOUVELLE FONCTION D'AGR√âGATION JS (INCLUSION DE LA DATE)
        // Regroupe les pr√©dictions (ex: 10min) en moyennes horaires.
        // Utilise le premier horodatage (Date et Heure) de l'heure pour l'affichage dans le tableau.
        // --------------------------------------------------------------------------------
        const aggregateToHourlyMean = (predictions) => {
            if (!predictions || predictions.length === 0) return [];
            
            const hourlyGroups = {};

            predictions.forEach((p, index) => {
                // Parse the time string (e.g., "2025-10-02 20:10")
                const date = new Date(p.time.replace(' ', 'T'));
                // Use the full hour string (e.g., "20") as the key
                const hourKey = date.getHours().toString().padStart(2, '0'); 

                if (!hourlyGroups[hourKey]) {
                    hourlyGroups[hourKey] = {
                        sum: 0,
                        count: 0,
                        // Store the full time string of the first point in this hour block
                        firstTime: p.time, 
                        // The actual first point's value, which will be the first value predicted in the hour
                        firstDateObj: date
                    };
                }
                
                // Si c'est le premier point de l'heure, met √† jour firstTime (redondant car g√©r√© au-dessus, mais plus s√ªr)
                if (date < hourlyGroups[hourKey].firstDateObj) {
                     hourlyGroups[hourKey].firstDateObj = date;
                     hourlyGroups[hourKey].firstTime = p.time;
                }

                hourlyGroups[hourKey].sum += p.value;
                hourlyGroups[hourKey].count += 1;
            });

            // Convert groups into the final required list format
            const aggregatedList = Object.values(hourlyGroups).map(group => {
                const date = new Date(group.firstTime.replace(' ', 'T'));
                
                // Format: DD/MM HH:MM (e.g., "02/10 20:10")
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const timePart = date.toTimeString().substring(0, 5); 
                
                const displayDateTime = `${day}/${month} ${timePart}`;
                
                return {
                    // C'est le premier temps de mesure de l'heure agr√©g√©e (ex: "02/10 20:10")
                    time: displayDateTime, 
                    // C'est la valeur moyenne pour le bloc horaire
                    value: group.sum / group.count 
                };
            });

            // Assurer un tri chronologique
            aggregatedList.sort((a, b) => a.time.localeCompare(b.time));
            
            return aggregatedList;
        };


        const displayMessage = (msg, type) => {
            messageContainer.textContent = msg;
            messageContainer.style.color = (type === 'error') ? '#ff4d4d' : 'black';
        };

        const fetchAndPopulateColumns = async () => {
            try {
                const response = await fetch('/get_data_columns');
                const result = await response.json();
                if (response.ok) {
                    allColumns = result.columns;
                    
                    const filteredTargets = allColumns.filter(col => 
                        targetKeywords.some(keyword => col.toLowerCase().includes(keyword))
                    );

                    populateSelect(targetColSelect, filteredTargets);

                    const defaultTarget = filteredTargets.find(col => col.toLowerCase().includes('temp√©rature'));
                    if (defaultTarget) {
                        targetColSelect.value = defaultTarget;
                    } else if (filteredTargets.length > 0) {
                        targetColSelect.value = filteredTargets[0];
                    }

                    updateExplanatoryVariables();
                } else {
                    displayMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('Erreur lors de la r√©cup√©ration des colonnes:', error);
                displayMessage('Une erreur est survenue lors du chargement des colonnes.', 'error');
            }
        };

        const populateSelect = (selectElement, options) => {
            selectElement.innerHTML = '';
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
        };

        // LOGIQUE DE FILTRAGE DES EXPLICATIVES
        const updateExplanatoryVariables = () => {
            const targetCol = targetColSelect.value;
            const lowerTargetCol = targetCol.toLowerCase();
            let isMeteoTarget = meteoKeywords.some(keyword => lowerTargetCol.includes(keyword));
            let isPollutantTarget = pollutantKeywords.some(keyword => lowerTargetCol.includes(keyword));

            const explanatoryColumns = allColumns.filter(col => {
                const lowerCol = col.toLowerCase();
                
                // 1. Exclure la variable cible
                if (col === targetCol) {
                    return false;
                }
                
                // 2. Exclure les colonnes permanentes
                const isPermanentlyExcluded = permanentExclusionsKeywords.some(keyword => lowerCol.includes(keyword));
                if (isPermanentlyExcluded) {
                    return false;
                }
                
                // 3. Logique de filtrage par type de cible
                if (isMeteoTarget) {
                    // Si la cible est M√âT√âO, n'afficher que les explicatives M√âT√âO (y compris lumi√®re)
                    return meteoKeywords.some(keyword => lowerCol.includes(keyword));
                } else if (isPollutantTarget) {
                    // Si la cible est POLLUANT, afficher TOUTES les explicatives restantes (M√©t√©o + Polluants)
                    return true;
                }

                return true;
            });
            
            populateSelect(explanatoryColsSelect, explanatoryColumns);
            
            // S√©lectionner TOUTES les variables explicatives par d√©faut
            Array.from(explanatoryColsSelect.options).forEach(option => {
                option.selected = true;
            });
        };

        const fetchCorrelationMatrix = async () => {
            correlationText.classList.add('hidden');
            correlationSpinner.classList.remove('hidden');
            getCorrelationBtn.disabled = true;

            displayMessage('G√©n√©ration de la matrice de corr√©lation...', 'info');
            correlationSection.classList.add('hidden');
            try {
                const response = await fetch('/get_correlation_matrix');
                const result = await response.json();
                if (response.ok) {
                    const plotData = JSON.parse(result.plot_json);
                    // --- MODIFICATION POUR MAXIMISER L'ESPACE DANS LE CARD ---
                    const layout = {
                        ...plotData.layout,
                        autosize: true, // Auto-ajustement √† la taille du conteneur
                        margin: { l: 2, r: 2, t: 3, b: 2 }, // Marges r√©duites
                    };

                    Plotly.newPlot('correlation-plot', plotData.data, plotData.layout, { responsive: true });
                    correlationSection.classList.remove('hidden');
                    displayMessage('Matrice de corr√©lation g√©n√©r√©e avec succ√®s !', 'success');
                } else {
                    displayMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('Erreur lors de la g√©n√©ration de la matrice de corr√©lation:', error);
                displayMessage('Une erreur inattendue est survenue.', 'error');
            } finally {
                correlationText.classList.remove('hidden');
                correlationSpinner.classList.add('hidden');
                getCorrelationBtn.disabled = false;
            }
        };

        const trainAndPredict = async () => {
            const targetCol = targetColSelect.value;
            const featureCols = Array.from(explanatoryColsSelect.options)
                                         .filter(option => option.selected)
                                         .map(option => option.value);

            if (!targetCol || featureCols.length === 0) {
                displayMessage('Veuillez s√©lectionner au moins une variable cible et une ou plusieurs variables explicatives.', 'error');
                return;
            }

            trainBtn.disabled = true;
            trainText.classList.add('hidden');
            trainSpinner.classList.remove('hidden');
            displayMessage('Entra√Ænement des mod√®les...', 'info');
            resultsSection.classList.add('hidden');

            try {
                const response = await fetch('/train_predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ targetCol: targetCol, featureCols: featureCols }), 
                });
                const result = await response.json();

                if (response.ok) {
                    
                    // ----------------------------------------------------
                    // AGR√âGATION JS : Pr√©dire 3h (18 points) -> Moyennes Horaires (3 points)
                    // ----------------------------------------------------
                    // Note: Le backend Python doit renvoyer la pr√©diction brute (10min) pour cette fonction JS
                    const predictions_rf_hourly = aggregateToHourlyMean(result.predictions_rf);
                    const predictions_gb_hourly = aggregateToHourlyMean(result.predictions_gb);
                    
                    // Donn√©es pour le tableau (bas√©es sur les moyennes horaires agr√©g√©es)
                    const predictionsData = predictions_gb_hourly.map((p_gb, index) => {
                        // Assurez-vous que les deux listes sont de la m√™me taille
                        const p_rf = predictions_rf_hourly[index] || { time: p_gb.time, value: 'N/A' };
                        
                        return {
                            // 'time' est la date et l'heure du premier temps de mesure de l'heure agr√©g√©e (ex: "02/10 20:10")
                            time: p_gb.time, 
                            // Utilisation de toFixed(2) pour l'affichage de la moyenne horaire
                            gb: typeof p_gb.value === 'number' ? p_gb.value.toFixed(2) : p_gb.value,
                            rf: typeof p_rf.value === 'number' ? p_rf.value.toFixed(2) : p_rf.value,
                        };
                    });
                    
                    // Construction du tableau HTML (utilise les donn√©es agr√©g√©es)
                    const tableHtml = `
                        <div id="predictionTableContainer" class="data-table mt-4 hidden">
                            <h3 class="text-xl font-bold mb-3 text-gray-800">Pr√©dictions Moyennes par Heure (3 Prochaines Heures)</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-gray-200 bg-white rounded-xl shadow-lg">
                                    <thead class="bg-gray-50">
                                        <tr>
                                            <th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Date et Heure de d√©but</th>
                                            <th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Gradient Boosting (Moy.)</th>
                                            <th class="px-4 py-2 text-left text-sm font-medium text-gray-500 uppercase tracking-wider">Random Forest (Moy.)</th>
                                        </tr>
                                    </thead>
                                    <tbody class="divide-y divide-gray-200">
                                        ${predictionsData.map(row => `
                                            <tr class="hover:bg-gray-50">
                                                <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${row.time}</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${row.gb}</td>
                                                <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-900">${row.rf}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                    
                    // ----------------------------------------------------
                    // MISE √Ä JOUR DES METRICS
                    // ----------------------------------------------------
                    
                    const rf_r2 = result.results['Random Forest']?.r2?.toFixed(4) || 'N/A';
                    const rf_mse = result.results['Random Forest']?.mse?.toFixed(4) || 'N/A';
                    const gb_r2 = result.results['Gradient Boosting']?.r2?.toFixed(4) || 'N/A';
                    const gb_mse = result.results['Gradient Boosting']?.mse?.toFixed(4) || 'N/A';

                    // Afficher les m√©triques de performance et le bouton pour le tableau
                    predictionMetricsDiv.innerHTML = `
                        <h3 class="text-xl font-bold mb-3 text-gray-800">Performance des Mod√®les</h3>
                        <p class="mb-2"><strong>Random Forest R¬≤:</strong> ${rf_r2}</p>
                        <p class="mb-2"><strong>Random Forest MSE:</strong> ${rf_mse}</p>
                        <p class="mb-2"><strong>Gradient Boosting R¬≤:</strong> ${gb_r2}</p>
                        <p class="mb-2"><strong>Gradient Boosting MSE:</strong> ${gb_mse}</p>
                        
                        <button id="toggleTableBtn" class="btn-gradient mt-4">
                            Afficher le Tableau des Pr√©dictions
                        </button>
                        ${tableHtml}
                    `;
                    
                    // Gestionnaire d'√©v√©nement pour le bouton "Afficher/Masquer le Tableau"
                    document.getElementById('toggleTableBtn').addEventListener('click', function() {
                        const tableContainer = document.getElementById('predictionTableContainer');
                        if (tableContainer.classList.contains('hidden')) {
                            tableContainer.classList.remove('hidden');
                            this.textContent = 'Masquer le Tableau des Pr√©dictions';
                        } else {
                            tableContainer.classList.add('hidden');
                            this.textContent = 'Afficher le Tableau des Pr√©dictions';
                        }
                    });

                    // ----------------------------------------------------
                    // MISE √Ä JOUR DU GRAPHIQUE (utilise les donn√©es agr√©g√©es)
                    // ----------------------------------------------------
                    
                    const plotData = {
                      data: [
                        { // Gradient Boosting (Moyenne Horaire)
                          x: (predictions_gb_hourly || []).map(p => p.time),
                          y: (predictions_gb_hourly || []).map(p => p.value),
                          mode: 'lines+markers',
                          name: 'Gradient Boosting',
                          line: { color: 'rgb(255, 105, 180)', width: 2 }
                        },
                         { // Random Forest (Moyenne Horaire)
                          x: (predictions_rf_hourly || []).map(p => p.time),
                          y: (predictions_rf_hourly || []).map(p => p.value),
                          mode: 'lines+markers',
                          name: 'Random Forest',
                          line: { color: 'rgb(75, 82, 255)', width: 2 }
                        },
                      ],
                      layout: {
                        title: `Pr√©dictions pour ${targetCol}`,
                        xaxis: { title: 'Date et Heure  de l\'intervalle', type: 'category' }, // TITRE MIS √Ä JOUR
                        yaxis: { title: targetCol },
                        margin: { l: 60, r: 60, b: 60, t: 60 },
                        legend: { orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1 }
                      }
                    };

                    Plotly.newPlot('prediction-plot', plotData.data, plotData.layout, { responsive: true });
                    
                    // Assurer l'ajustement √† la pleine largeur
                    setTimeout(() => {
                        Plotly.relayout('prediction-plot', {autosize: true});
                    }, 100);

                    displayMessage('Mod√®les entra√Æn√©s et pr√©dictions g√©n√©r√©es avec succ√®s ! üéâ', 'success');
                    resultsSection.classList.remove('hidden');
                    redirectBtnContainer.classList.remove('hidden');
                    downloadPredictionBtn.classList.remove('hidden');

                } else {
                    displayMessage(result.error || 'Erreur inconnue lors de l\'entra√Ænement. V√©rifiez la taille de votre jeu de donn√©es.', 'error');
                }
            } catch (error) {
                console.error('Erreur lors de l\'entra√Ænement du mod√®le:', error);
                displayMessage('Une erreur inattendue est survenue lors de l\'entra√Ænement du mod√®le. Le jeu de donn√©es est peut-√™tre trop petit.', 'error');
            } finally {
                trainBtn.disabled = false;
                trainText.classList.remove('hidden');
                trainSpinner.classList.add('hidden');
            }
        };

        downloadCorrelationBtn.addEventListener('click', () => {
            Plotly.downloadImage('correlation-plot', { format: 'png', filename: 'matrice_correlation' });
        });

        downloadPredictionBtn.addEventListener('click', () => {
            Plotly.downloadImage('prediction-plot', { format: 'png', filename: 'graphique_prediction_horaire' });
        });

        document.addEventListener('DOMContentLoaded', () => {
            fetchAndPopulateColumns();
            getCorrelationBtn.addEventListener('click', fetchCorrelationMatrix);
            predictionForm.addEventListener('submit', function(e) {
                e.preventDefault();
                trainAndPredict();
            });
            targetColSelect.addEventListener('change', updateExplanatoryVariables);
        });
        
        // G√©rer le redimensionnement pour que Plotly prenne toute la place
        window.addEventListener('resize', () => {
            if (document.getElementById('prediction-plot').hasChildNodes()) {
                Plotly.relayout('prediction-plot', {autosize: true});
            }
        });
    </script>
</body>
</html>